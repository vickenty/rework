use syntax::*;

pub program -> Elem<'input> =
    a:list<item> b:Ws
    { node!("program", a, b) }

item -> Elem<'input> =
    use_item /
    struct_item /
    enum_item /
    type_item /
    fn_item

use_item -> Elem<'input> =
    a:opt<Pub> b:Use c:S<[^;]+> d:S<";">
    { node!("use_item", a, b, c, d) }

struct_item -> Elem<'input> =
    a:list<attribute> b:opt<Pub> c:Struct d:Ident e:struct_body
    { node!("struct_item", a, b, c, d, e) }

struct_body -> Elem<'input> =
    a:tuple_struct_body b:S<";">
    { node!("struct_body", a, b) }
    /
    a:S<";">
    { node!("struct_body", a) }
    /
    a:named_struct_body
    { node!("struct_body", a) }

tuple_struct_body -> Elem<'input> =
    a:S<"("> b:opt<Pub> c:csep<type_name> d:S<")">
    { node!("tuple_struct_body", a, b, c, d) }

named_struct_body -> Elem<'input> =
    a:S<"{"> b:opt<csep<struct_field>> c:S<"}">
    { node!("named_struct_body", a, b, c) }

struct_field -> Elem<'input> =
    a:opt<Pub> b:Ident c:S<":"> d:type_name
    { node!("struct_field", a, b, c, d) }

enum_item -> Elem<'input> =
    a:list<attribute> b:opt<Pub> c:Enum d:Ident e:enum_body
    { node!("enum_item", a, b, c, d, e) }

enum_body -> Elem<'input> =
    a:S<"{"> b:csep<enum_variant> c:S<"}">
    { node!("enum_body", a, b, c) }

enum_variant -> Elem<'input> =
    a:Ident b:opt<enum_variant_body>
    { node!("variant", a, b) }

enum_variant_body -> Elem<'input> =
    tuple_struct_body /
    named_struct_body

attribute -> Elem<'input> =
     a:S<"#["> b:Ident c:opt<attribute_arguments> d:S<"]">
     { node!("attribute", a, b, c, d) }

attribute_arguments -> Elem<'input> =
    a:S<"("> b:csep<Ident> c:S<")">
    { node!("attribute_arguments", a, b, c) }

type_item -> Elem<'input> =
    a:opt<Pub> b:Type c:type_decl d:S<"="> e:type_name f:S<";">
    { node!("type_item", a, b, c, d, e, f) }

type_decl -> Elem<'input> =
    a:Ident b:opt<type_parameters>
    { node!("type_decl", a, b) }

type_parameters -> Elem<'input> =
    a:S<"<"> b:csep<type_parameter> c:S<">">
    { node!("type_parameters", a, b, c) }

type_parameter -> Elem<'input> =
    a:Ident b:opt<type_bound>
    { node!("type_parameter", a, b) }

type_bound -> Elem<'input> =
    a:S<":"> b:type_name
    { node!("type_bound", a, b) }

fn_item -> Elem<'input> =
    a:opt<Pub> b:Fn c:fn_signature d:block
    { node!("fn_item", a, b, c, d) }

fn_signature -> Elem<'input> =
    a:Ident b:fn_parameters c:opt<fn_return_type>
    { node!("fn_signature", a, b, c) }

fn_parameters -> Elem<'input> =
    a:S<"("> b:csep<fn_parameter> c:S<")">
    { node!("fn_parameters", a, b, c) }

fn_parameter -> Elem<'input> =
    a:pattern b:S<":"> c:type_name
    { node!("fn_parameter", a, b, c) }

fn_return_type -> Elem<'input> =
    a:S<"->"> b:type_name
    { node!("fn_return_type", a, b) }

pattern -> Elem<'input> =
    a:pattern0
    { node!("pattern", a) }

pattern0 -> Elem<'input> =
    expr_path
    // TOOD

block -> Elem<'input> =
    a:S<"{"> b:list<stmt> c:opt<expr> d:S<"}">
    { node!("block", a, b, c, d) }

stmt -> Elem<'input> =
    let_stmt /
    expr_stmt

let_stmt -> Elem<'input> =
    a:S<"let"> b:pattern c:S<"="> d:expr e:S<";">
    { node!("let_stmt", a, b, c, d, e) }

expr_stmt -> Elem<'input> =
    a:expr b:S<";">
    { node!("expr_stmt", a, b) }

type_name -> Elem<'input> =
    a:type_path_elem<opt<S<"::">>> b:type_path_elem<S<"::">>*
    { node_vec("type_name", prepend(a, b)) }

type_arguments<prefix> =
    a:prefix b:S<"<"> c:csep<type_name> d:S<">">
    { node!("type_arguments", a, b, c, d) }

type_path_elem<prefix> =
    a:prefix b:Ident c:opt<type_arguments<empty>>
    { node!("path_elem", a, b, c) }

expr -> Elem<'input> =
    prim

prim -> Elem<'input> =
    expr_path

expr_path -> Elem<'input> =
    a:expr_path_elem<opt<S<"::">>> b:expr_path_elem<S<"::">>*
    { node_vec("expr_path", prepend(a, b)) }

expr_path_elem<prefix> =
    a:prefix b:Ident c:opt<type_arguments<S<"::">>>
    { node!("path_elem", a, b, c) }

empty -> Elem<'input> = { node!("empty") }

// Whitespace
_ = ([ \t\n] / "//" [^\n]* "\n")*

Ws -> Elem<'input> =
    p:$(_)
    { text(p, "") }

// Symbols and punctuation: parens, brackets, comma, and such.
S<ex> = p:$(_) t:$(ex) {
    text(p, t)
}

// Keywords
K<ex> = p:$(_) t:$(ex) ![a-zA-Z0-9_] {
    text(p, t)
}

Enum -> Elem<'input> = K<"enum">
Pub -> Elem<'input> = K<"pub">
Struct -> Elem<'input> = K<"struct">
Type -> Elem<'input> = K<"type">
Use -> Elem<'input> = K<"use">
Fn -> Elem<'input> = K<"fn">

// Identifiers
Ident -> Elem<'input> =
    p:$(_) t:$([a-zA-Z_] [a-zA-Z0-9_]*)
    { text(p, t) }

// Comma-separated lists
csep<ex> =
    xs:cs_elem<ex>* x:cs_last<ex>?
    { node_vec("comma_list", append(xs, x)) }

cs_elem<ex> =
    e:ex c:S<",">
    { node!("comma_elem", e, c) }

cs_last<ex> =
    e:ex
    { node!("comma_elem", e) }

// Non-separated lists
list<ex> =
    xs:list_elem<ex>*
    { node_vec("list", xs) }

list_elem<ex> =
    e:ex
    { node!("list_elem", e) }

// Optional elements
opt<ex> =
    e:ex?
    { e.unwrap_or_else(|| node!("empty")) }
