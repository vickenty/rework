use syntax::*;

pub program -> Elem<'input> =
    a:list<item> b:Ws
    { node!("program", a, b) }

item -> Elem<'input> =
    use_item /
    struct_item /
    enum_item /
    type_item /
    fn_item

use_item -> Elem<'input> =
    a:opt<Pub> b:Use c:S<[^;]+> d:S<";">
    { node!("use_item", a, b, c, d) }

struct_item -> Elem<'input> =
    a:list<attribute> b:opt<Pub> c:Struct d:Ident e:opt<type_parameters> f:struct_body
    { node!("struct_item", a, b, c, d, e, f) }

struct_body -> Elem<'input> =
    a:tuple_struct_body b:S<";">
    { node!("struct_body", a, b) }
    /
    a:S<";">
    { node!("struct_body", a) }
    /
    a:named_struct_body
    { node!("struct_body", a) }

tuple_struct_body -> Elem<'input> =
    a:S<"("> b:opt<Pub> c:csep<type_name> d:S<")">
    { node!("tuple_struct_body", a, b, c, d) }

named_struct_body -> Elem<'input> =
    a:S<"{"> b:opt<csep<struct_field>> c:S<"}">
    { node!("named_struct_body", a, b, c) }

struct_field -> Elem<'input> =
    a:opt<Pub> b:Ident c:S<":"> d:type_name
    { node!("struct_field", a, b, c, d) }

enum_item -> Elem<'input> =
    a:list<attribute> b:opt<Pub> c:Enum d:Ident e:opt<type_parameters> f:enum_body
    { node!("enum_item", a, b, c, d, e, f) }

enum_body -> Elem<'input> =
    a:S<"{"> b:csep<enum_variant> c:S<"}">
    { node!("enum_body", a, b, c) }

enum_variant -> Elem<'input> =
    a:Ident b:opt<enum_variant_body>
    { node!("variant", a, b) }

enum_variant_body -> Elem<'input> =
    tuple_struct_body /
    named_struct_body

attribute -> Elem<'input> =
     a:S<"#["> b:Ident c:opt<attribute_arguments> d:S<"]">
     { node!("attribute", a, b, c, d) }

attribute_arguments -> Elem<'input> =
    a:S<"("> b:csep<Ident> c:S<")">
    { node!("attribute_arguments", a, b, c) }

type_item -> Elem<'input> =
    a:opt<Pub> b:Type c:type_decl d:S<"="> e:type_name f:S<";">
    { node!("type_item", a, b, c, d, e, f) }

type_decl -> Elem<'input> =
    a:Ident b:opt<type_parameters>
    { node!("type_decl", a, b) }

type_parameters -> Elem<'input> =
    a:S<"<"> b:csep<type_parameter> c:S<">">
    { node!("type_parameters", a, b, c) }

type_parameter -> Elem<'input> =
    a:Ident b:opt<type_bound>
    { node!("type_parameter", a, b) }

type_bound -> Elem<'input> =
    a:S<":"> b:type_name
    { node!("type_bound", a, b) }

fn_item -> Elem<'input> =
    a:opt<Pub> b:opt<Unsafe> c:opt<fn_abi> d:Fn e:fn_signature f:block
    { node!("fn_item", a, b, c, d, e, f) }

fn_abi -> Elem<'input> =
    a:Extern b:opt<String>
    { node!("fn_abi", a, b) }

fn_signature -> Elem<'input> =
    a:Ident b:fn_parameters<fn_param_name> c:opt<fn_return_type>
    { node!("fn_signature", a, b, c) }

fn_parameters<param_name> =
    a:S<"("> b:csep<fn_parameter<param_name>> c:S<")">
    { node!("fn_parameters", a, b, c) }

fn_parameter<param_name> =
    a:param_name b:type_name
    { node!("fn_parameter", a, b) }

fn_param_name -> Elem<'input> =
    a:pattern b:S<":">
    { node!("fn_param_name") }

fn_return_type -> Elem<'input> =
    a:S<"->"> b:type_name
    { node!("fn_return_type", a, b) }

pattern -> Elem<'input> =
    a:pattern0
    { node!("pattern", a) }

pattern0 -> Elem<'input> =
    expr_path
    // TOOD

block -> Elem<'input> =
    a:S<"{"> b:list<stmt> c:opt<expr> d:S<"}">
    { node!("block", a, b, c, d) }

stmt -> Elem<'input> =
    let_stmt /
    expr_stmt

let_stmt -> Elem<'input> =
    a:S<"let"> b:pattern c:S<"="> d:expr e:S<";">
    { node!("let_stmt", a, b, c, d, e) }

expr_stmt -> Elem<'input> =
    a:expr b:S<";">
    { node!("expr_stmt", a, b) }

pub type_name -> Elem<'input> =
    type_expr /
    type_prim

type_expr -> Elem<'input> =
    a:type_prim b:S<"+"> c:(type_name / lifetime)
    { node!("type_expr", a, b, c) }

type_prim -> Elem<'input> =
    type_impl /
    type_fn /
    type_fn_trait /
    type_path /
    type_slice /
    type_array /
    type_tuple /
    type_ref /
    type_ptr /
    type_as /
    type_never /
    type_group

type_path -> Elem<'input> =
    a:opt<type_late_lifetime> b:type_path_list
    { node!("type_path", a, b) }

type_path_list -> Elem<'input> =
    a:type_path_elem<opt<S<"::">>> b:type_path_elem<S<"::">>*
    { node_vec("type_path_list", prepend(a, b)) }

type_path_elem<prefix> =
    a:prefix b:Ident c:opt<type_arguments<empty>>
    { node!("type_path_elem", a, b, c) }

type_arguments<prefix> =
    a:prefix b:S<"<"> c:csep<type_assoc / type_name / lifetime> d:S<">">
    { node!("type_arguments", a, b, c, d) }

type_assoc -> Elem<'input> =
    a:Ident b:S<"="> c:type_name
    { node!("type_assoc", a, b, c) }

type_slice -> Elem<'input> =
    a:S<"["> b:type_name c:S<"]">
    { node!("type_slice", a, b, c) }

type_array -> Elem<'input> =
    a:S<"["> b:type_name c:S<";"> d:expr e:S<"]">
    { node!("type_array", a, b, c, d, e) }

type_tuple -> Elem<'input> =
    a:S<"("> b:csep_tuple<type_name> c:S<")">
    { node!("type_tuple", a, b, c) }

type_ref -> Elem<'input> =
    a:S<"&"> b:opt<lifetime> c:opt<Mut> d:type_name
    { node!("type_ref", a, b, c, d) }

type_ptr -> Elem<'input> =
    a:S<"*"> b:(Mut / Const) c:type_name
    { node!("type_ptr", a, b, c) }

type_as -> Elem<'input> =
    a:type_as_body b:type_path_elem<S<"::">>+
    { node_vec("type_as", prepend(a, b)) }

type_as_body -> Elem<'input> =
    a:S<"<"> b:type_name c:opt<type_as_trait> d:S<">">
    { node!("type_as_body", a, b, c, d) }

type_as_trait -> Elem<'input> =
    a:As b:type_path
    { node!("type_as_trait", a, b) }

type_impl -> Elem<'input> =
    a:Impl b:type_name
    { node!("type_impl", a, b) }

type_fn -> Elem<'input> =
    a:opt<type_late_lifetime> b:opt<Unsafe> c:opt<fn_abi> d:Fn e:type_fn_signature
    { node!("type_fn", a, b, c, d, e) }

type_late_lifetime -> Elem<'input> =
    a:For b:S<"<"> c:csep<lifetime> d:S<">">
    { node!("type_late_lifetime", a, b, c, d) }

type_fn_signature -> Elem<'input> =
    a:fn_parameters<opt<type_fn_param_name>> b:opt<fn_return_type>
    { node!("type_fn_signature", a, b) }

type_fn_param_name -> Elem<'input> =
    a:Ident b:S<":">
    { node!("fn_param_name", a, b) }

type_never -> Elem<'input> =
    S<"!">

type_group -> Elem<'input> =
    a:S<"("> b:type_name c:S<")">
    { node!("type_group", a, b, c) }

type_fn_trait -> Elem<'input> =
    a:opt<type_late_lifetime> b:FnTrait c:type_fn_signature
    { node!("type_fn_trait", a, b, c) }

lifetime -> Elem<'input> =
    a:Lifetime
    { node!("lifetime", a) }

expr -> Elem<'input> =
    prim

prim -> Elem<'input> =
    expr_path

expr_path -> Elem<'input> =
    a:expr_path_elem<opt<S<"::">>> b:expr_path_elem<S<"::">>*
    { node_vec("expr_path", prepend(a, b)) }

expr_path_elem<prefix> =
    a:prefix b:Ident c:opt<type_arguments<S<"::">>>
    { node!("path_elem", a, b, c) }

empty -> Elem<'input> = { node!("empty") }

// Whitespace
_ = ([ \t\n] / "//" [^\n]* "\n")*

Ws -> Elem<'input> =
    p:$(_)
    { text(p, "") }

// Symbols and punctuation: parens, brackets, comma, and such.
S<ex> = p:$(_) t:$(ex) {
    text(p, t)
}

// Keywords
K<ex> = p:$(_) t:$(ex) ![a-zA-Z0-9_] {
    text(p, t)
}

Enum -> Elem<'input> = K<"enum">
Pub -> Elem<'input> = K<"pub">
Struct -> Elem<'input> = K<"struct">
Type -> Elem<'input> = K<"type">
Use -> Elem<'input> = K<"use">
Fn -> Elem<'input> = K<"fn">
Mut -> Elem<'input> = K<"mut">
Const -> Elem<'input> = K<"const">
Impl -> Elem<'input> = K<"impl">
Unsafe -> Elem<'input> = K<"unsafe">
Extern -> Elem<'input> = K<"extern">
For -> Elem<'input> = K<"for">
As -> Elem<'input> = K<"as">
FnTrait -> Elem<'input> = K<"FnOnce"> / K<"FnMut"> / K<"FnBox"> / K<"Fn">

// Identifiers
Ident -> Elem<'input> =
    p:$(_) t:IdentLiteral
    { text(p, t) }

IdentLiteral -> &'input str =
    $([a-zA-Z_] [a-zA-Z0-9_]*)

Lifetime -> Elem<'input> =
    p:$(_) t:$( "'" IdentLiteral)
    { text(p, t) }

// Literals
String -> Elem<'input> =
    p:$(_) t:$(StringLiteral)
    { text(p, t) }

StringLiteral =
    // FIXME
    "\"" [^"] "\""

// Comma-separated lists
csep<ex> =
    xs:cs_elem<ex>* x:cs_last<ex>?
    { node_vec("comma_list", append(xs, x)) }

// Comma-separated list inside tuple, requires trailing comma for a one element list.
csep_tuple<ex> =
    xs:cs_elem<ex>+ x:cs_last<ex>?
    { node_vec("comma_list", append(xs, x)) }

cs_elem<ex> =
    e:ex c:S<",">
    { node!("comma_elem", e, c) }

cs_last<ex> =
    e:ex
    { node!("comma_elem", e) }

// Non-separated lists
list<ex> =
    xs:list_elem<ex>*
    { node_vec("list", xs) }

list_elem<ex> =
    e:ex
    { node!("list_elem", e) }

// Optional elements
opt<ex> =
    e:ex?
    { e.unwrap_or_else(|| node!("empty")) }
