use syntax::*;

#![arguments(struct_literal: bool)]

pub program -> Elem<'input> =
    a:list<item> b:Ws
    { node!("program", a, b) }

item -> Elem<'input> =
    item_use /
    item_struct /
    item_enum /
    item_type /
    item_fn

item_use -> Elem<'input> =
    a:opt<Pub> b:Use c:S<[^;]+> d:S<";">
    { node!("item_use", a, b, c, d) }

item_struct -> Elem<'input> =
    a:list<attribute> b:opt<Pub> c:Struct d:Ident e:opt<type_parameters> f:struct_body
    { node!("item_struct", a, b, c, d, e, f) }

struct_body -> Elem<'input> =
    a:tuple_struct_body b:S<";">
    { node!("struct_body", a, b) }
    /
    a:S<";">
    { node!("struct_body", a) }
    /
    a:named_struct_body
    { node!("struct_body", a) }

tuple_struct_body -> Elem<'input> =
    a:S<"("> b:opt<Pub> c:csep<type_name> d:S<")">
    { node!("tuple_struct_body", a, b, c, d) }

named_struct_body -> Elem<'input> =
    a:S<"{"> b:opt<csep<struct_field>> c:S<"}">
    { node!("named_struct_body", a, b, c) }

struct_field -> Elem<'input> =
    a:opt<Pub> b:Ident c:S<":"> d:type_name
    { node!("struct_field", a, b, c, d) }

item_enum -> Elem<'input> =
    a:list<attribute> b:opt<Pub> c:Enum d:Ident e:opt<type_parameters> f:enum_body
    { node!("item_enum", a, b, c, d, e, f) }

enum_body -> Elem<'input> =
    a:S<"{"> b:csep<enum_variant> c:S<"}">
    { node!("enum_body", a, b, c) }

enum_variant -> Elem<'input> =
    a:Ident b:opt<enum_variant_body>
    { node!("variant", a, b) }

enum_variant_body -> Elem<'input> =
    tuple_struct_body /
    named_struct_body

attribute -> Elem<'input> =
     a:S<"#["> b:Ident c:opt<attribute_arguments> d:S<"]">
     { node!("attribute", a, b, c, d) }

attribute_arguments -> Elem<'input> =
    a:S<"("> b:csep<Ident> c:S<")">
    { node!("attribute_arguments", a, b, c) }

item_type -> Elem<'input> =
    a:opt<Pub> b:Type c:type_decl d:S<"="> e:type_name f:S<";">
    { node!("item_type", a, b, c, d, e, f) }

type_decl -> Elem<'input> =
    a:Ident b:opt<type_parameters>
    { node!("type_decl", a, b) }

type_parameters -> Elem<'input> =
    a:S<"<"> b:csep<type_parameter> c:S<">">
    { node!("type_parameters", a, b, c) }

type_parameter -> Elem<'input> =
    a:Ident b:opt<type_bound>
    { node!("type_parameter", a, b) }

type_bound -> Elem<'input> =
    a:S<":"> b:type_name
    { node!("type_bound", a, b) }

item_fn -> Elem<'input> =
    a:opt<Pub> b:opt<Unsafe> c:opt<fn_abi> d:Fn e:fn_signature f:block
    { node!("item_fn", a, b, c, d, e, f) }

fn_abi -> Elem<'input> =
    a:Extern b:opt<string>
    { node!("fn_abi", a, b) }

fn_signature -> Elem<'input> =
    a:Ident b:fn_parameters<fn_param_name<pattern>> c:opt<fn_return_type>
    { node!("fn_signature", a, b, c) }

fn_parameters<param_name> =
    a:S<"("> b:csep<fn_parameter<param_name>> c:S<")">
    { node!("fn_parameters", a, b, c) }

fn_parameter<param_name> =
    a:param_name b:type_name
    { node!("fn_parameter", a, b) }

fn_param_name<binding> =
    a:binding b:S<":">
    { node!("fn_param_name", a, b) }

fn_return_type -> Elem<'input> =
    a:S<"->"> b:type_name
    { node!("fn_return_type", a, b) }

pub pattern -> Elem<'input> =
    a:pattern0 b:opt<type_bound>
    { node!("pattern", a, b) }

pattern0 -> Elem<'input> =
    pattern_literal /
    pattern_bind /
    pattern_tuple /
    pattern_path /
    pattern_ref /
    pattern_qual

pattern_follow<head, tail> =
    head:head tail:tail?
    {
        if let Some((kind, elems)) = tail {
            node_vec(kind, prepend(head, elems))
        } else {
            head
        }
    }

pattern_literal -> Elem<'input> =
    pattern_follow<literal, pattern_range>

pattern_range -> (&'static str, Vec<Elem<'input>>) =
    a:S<Range> b:(literal / expr_path)
    { ("pattern_range", vec![a, b]) }

literal -> Elem<'input> =
    float /
    integer /
    char /
    string

pattern_ref -> Elem<'input> =
    a:S<"&"> b:pattern
    { node!("pattern_ref", a, b) }

pattern_bind -> Elem<'input> =
    a:K<"ref"> b:Ident c:opt<pattern_at>
    { node!("pattern_bind", a, b, c) }
    /
    a:Ident b:pattern_at
    { node!("pattern_bind", node!("empty"), a, b) }

pattern_at -> Elem<'input> =
    a:S<"@"> b:pattern
    { node!("pattern_at", a, b) }

pattern_tuple -> Elem<'input> =
    a:S<"("> b:opt<csep_tuple<pattern>> c:S<")">
    { node!("pattern_tuple", a, b, c) }

pattern_path -> Elem<'input> =
    pattern_follow<expr_path, pattern_path_tail>

pattern_path_tail -> (&'static str, Vec<Elem<'input>>) =
    a:(pattern_struct_tuple / pattern_struct_named)
    { ("pattern_struct", vec![ a ]) }
    /
    pattern_range

pattern_struct_tuple -> Elem<'input> =
    a:S<"("> b:csep<pattern> c:S<")">
    { node!("pattern_struct_tuple", a, b, c) }

pattern_struct_named -> Elem<'input> =
    a:S<"{"> b:csep<pattern_struct_field> c:S<"}">
    { node!("pattern_struct_named", a, b, c) }

pattern_struct_field -> Elem<'input> =
    a:K<"ref"> b:Ident
    { node!("pattern_struct_field", a, b, node!("empty")) }
    /
    a:Ident b:opt<pattern_struct_field_pat>
    { node!("pattern_struct_field", node!("empty"), a, b) }

pattern_struct_field_pat -> Elem<'input> =
    a:S<":"> b:pattern
    { node!("pattern_struct_field_pat", a, b) }

pattern_qual -> Elem<'input> =
    a:expr_qual
    { node!("pattern_qual", a) }

block -> Elem<'input> =
    a:S<"{"> b:list<stmt> c:opt<expr> d:S<"}">
    { node!("block", a, b, c, d) }

stmt -> Elem<'input> =
    stmt_let /
    stmt_expr

stmt_let -> Elem<'input> =
    a:S<"let"> b:pattern c:S<"="> d:expr e:S<";">
    { node!("stmt_let", a, b, c, d, e) }

stmt_expr -> Elem<'input> =
    a:expr b:S<";">
    { node!("stmt_expr", a, b) }

pub type_name -> Elem<'input> =
    a:sep_list1<type_prim / lifetime, S<"+">>
    { node!("type_name", a) }

type_expr -> Elem<'input> =
    a:type_prim b:S<"+"> c:(type_name / lifetime)
    { node!("type_expr", a, b, c) }

type_prim -> Elem<'input> =
    type_impl /
    type_fn /
    type_fn_trait /
    type_path /
    type_slice /
    type_array /
    type_tuple /
    type_ref /
    type_ptr /
    type_as /
    type_never /
    type_group

type_path -> Elem<'input> =
    a:opt<type_late_lifetime> b:type_path_list
    { node!("type_path", a, b) }

type_path_list -> Elem<'input> =
    a:type_path_elem<opt<S<"::">>> b:type_path_elem<S<"::">>*
    { node_vec("type_path_list", prepend(a, b)) }

type_path_elem<prefix> =
    a:prefix b:Ident c:opt<type_arguments<empty>>
    { node!("type_path_elem", a, b, c) }

type_arguments<prefix> =
    a:prefix b:S<"<"> c:csep<type_assoc / type_name / lifetime> d:S<">">
    { node!("type_arguments", a, b, c, d) }

type_assoc -> Elem<'input> =
    a:Ident b:S<"="> c:type_name
    { node!("type_assoc", a, b, c) }

type_slice -> Elem<'input> =
    a:S<"["> b:type_name c:S<"]">
    { node!("type_slice", a, b, c) }

type_array -> Elem<'input> =
    a:S<"["> b:type_name c:S<";"> d:expr e:S<"]">
    { node!("type_array", a, b, c, d, e) }

type_tuple -> Elem<'input> =
    a:S<"("> b:opt<csep_tuple<type_name>> c:S<")">
    { node!("type_tuple", a, b, c) }

type_ref -> Elem<'input> =
    a:S<"&"> b:opt<lifetime> c:opt<Mut> d:type_name
    { node!("type_ref", a, b, c, d) }

type_ptr -> Elem<'input> =
    a:S<"*"> b:(Mut / Const) c:type_name
    { node!("type_ptr", a, b, c) }

type_as -> Elem<'input> =
    a:type_as_body b:type_path_elem<S<"::">>+
    { node_vec("type_as", prepend(a, b)) }

type_as_body -> Elem<'input> =
    a:S<"<"> b:type_name c:opt<type_as_trait> d:S<">">
    { node!("type_as_body", a, b, c, d) }

type_as_trait -> Elem<'input> =
    a:As b:type_path
    { node!("type_as_trait", a, b) }

type_impl -> Elem<'input> =
    a:Impl b:type_name
    { node!("type_impl", a, b) }

type_fn -> Elem<'input> =
    a:opt<type_late_lifetime> b:opt<Unsafe> c:opt<fn_abi> d:Fn e:type_fn_signature
    { node!("type_fn", a, b, c, d, e) }

type_late_lifetime -> Elem<'input> =
    a:For b:S<"<"> c:csep<lifetime> d:S<">">
    { node!("type_late_lifetime", a, b, c, d) }

type_fn_signature -> Elem<'input> =
    a:fn_parameters<type_fn_param_name> b:opt<fn_return_type>
    { node!("type_fn_signature", a, b) }

type_fn_param_name -> Elem<'input> =
    opt<fn_param_name<Ident>>

type_never -> Elem<'input> =
    S<"!">

type_group -> Elem<'input> =
    a:S<"("> b:type_name c:S<")">
    { node!("type_group", a, b, c) }

type_fn_trait -> Elem<'input> =
    a:opt<type_late_lifetime> b:FnTrait c:type_fn_signature
    { node!("type_fn_trait", a, b, c) }

pub expr -> Elem<'input> =
    a:expr_inner
    { node!("expr", a) }

expr_inner -> Elem<'input> =
    expr_assign

expr_assign -> Elem<'input> = #infix<expr_assign_operand> {
    #R  a b:S<Assign> c { node!("binop", a, b, c) }
    #R  a b:S<"<-"> c { node!("binop", a, b, c) }
}

Assign = ("*" / "/" / "%" / "+" / "-" / "<<" / ">>" / "&" / "|" / "^")? "="

expr_assign_operand -> Elem<'input> =
    expr_range /
    expr_binop

expr_range -> Elem<'input> =
    a:opt<expr_binop> b:S<Range> c:opt<expr_binop>
    { node!("binop", a, b, c) }

Range = "..." / "..=" / ".."

expr_binop -> Elem<'input> = #infix<expr_cast> {
    #L  a b:S<"||"> c { node!("binop", a, b, c) }
    #L  a b:S<"&&"> c { node!("binop", a, b, c) }
    #L  a b:S<Compare> c { node!("binop", a, b, c) }
    #L  a b:S<"|"> c { node!("binop", a, b, c) }
    #L  a b:S<"^"> c { node!("binop", a, b, c) }
    #L  a b:S<"&"> c { node!("binop", a, b, c) }
    #L  a b:S<"<<"> c { node!("binop", a, b, c) }
        a b:S<">>"> c { node!("binop", a, b, c) }
    #L  a b:S<[+-]> c { node!("binop", a, b, c) }
    #L  a b:S<[*/%]> c { node!("binop", a, b, c) }
}

Compare = "<" !"-" "="? / ">" "="? / [!=] "="

expr_cast -> Elem<'input> =
    expr_cast0 /
    expr_prefix

// Helper to avoid left-recursion for suffix operators
suffix_expr<head, tail> =
    head:head tail:tail*
    { tail.into_iter().fold(head, |a, (kind, es)| node_vec(kind, prepend(a, es))) }

expr_cast0 -> Elem<'input> =
    suffix_expr<expr_prefix, expr_cast_tail>

expr_cast_tail -> (&'static str, Vec<Elem<'input>>) =
    a:As b:type_prim
    { ("expr_as", vec![a, b]) }

expr_prefix -> Elem<'input> =
    a:(S<[!*-]> / refop) b:expr_prefix
    { node!("expr_prefix", a, b) }
    /
    expr_suffix

refop -> Elem<'input> =
    a:S<"&"> b:opt<Mut>
    { node!("refop", a, b) }

expr_suffix -> Elem<'input> =
    suffix_expr<expr_prim, expr_suffix_tail>

expr_suffix_tail -> (&'static str, Vec<Elem<'input>>) =
    expr_index /
    expr_call /
    expr_field

expr_index -> (&'static str, Vec<Elem<'input>>) =
    a:S<"["> b:expr_inner c:S<"]">
    { ("expr_index", vec![a, b, c]) }

expr_call -> (&'static str, Vec<Elem<'input>>) =
    a:S<"("> b:csep<expr_inner> c:S<")">
    { ("expr_call", vec![a, b, c]) }

expr_field -> (&'static str, Vec<Elem<'input>>) =
    a:S<"."> b:(T<IntegerDec> / Ident)
    { ("expr_field", vec![a, b]) }

expr_prim -> Elem<'input> =
    literal /
    block /
    expr_loop /
    expr_for /
    expr_while /
    expr_if /
    expr_return /
    expr_break /
    expr_match /
    expr_closure /
    expr_struct /
    expr_qual /
    expr_array /
    expr_tuple /
    expr_group

expr_struct -> Elem<'input> =
    a:expr_path b:expr_struct_ctor?
    {
        if let Some(b) = b {
            node!("expr_struct", a, b)
        } else {
            a
        }
    }

expr_struct_ctor -> Elem<'input> =
    &struct_ctor_allowed a:S<"{"> b:csep<struct_ctor_field> c:S<"}">
    { node!("struct_ctor", a, b, c) }

struct_ctor_allowed =
    {?
        if struct_literal {
            Ok(())
        } else {
            Err("")
        }
    }

struct_ctor_field -> Elem<'input> =
    a:Ident b:opt<struct_ctor_value>
    { node!("struct_ctor_field", a, b) }

struct_ctor_value -> Elem<'input> =
    a:S<":"> b:expr
    { node!("struct_ctor_value", a, b) }

expr_path -> Elem<'input> =
    a:expr_path_elem<opt<S<"::">>> b:expr_path_elem<S<"::">>*
    { node_vec("expr_path", prepend(a, b)) }

expr_path_elem<prefix> =
    a:prefix b:Ident c:opt<type_arguments<S<"::">>>
    { node!("path_elem", a, b, c) }

expr_qual -> Elem<'input> =
    a:type_as_body b:expr_path_elem<S<"::">>+
    { node_vec("expr_qual", prepend(a, b)) }

expr_array -> Elem<'input> =
    a:S<"["> b:expr_array_body c:S<"]">
    { node!("array", a, b, c) }

expr_array_body -> Elem<'input> =
    expr_array_copy /
    expr_array_list

expr_array_list -> Elem<'input> =
    csep<expr>

expr_array_copy -> Elem<'input> =
    a:expr b:S<";"> c:expr
    { node!("array_copy", a, b, c) }

expr_tuple -> Elem<'input> =
    a:S<"("> b:opt<csep_tuple<expr_inner>> c:S<")">
    { node!("expr_tuple", a, b, c) }

expr_group -> Elem<'input> =
    a:S<"("> b:expr_inner<( true )> c:S<")">
    { node!("expr_group", a, b, c) }

expr_loop -> Elem<'input> =
    a:Loop b:block
    { node!("expr_loop", a, b) }

expr_for -> Elem<'input> =
    a:For b:pattern c:In d:expr_no_struct e:block
    { node!("expr_for", a, b, c, d, e) }

expr_no_struct -> Elem<'input> =
    a:expr<(false)>
    { a }

expr_while -> Elem<'input> =
    a:While b:condition c:block
    { node!("expr_while", a, b, c) }

condition -> Elem<'input> =
    let_pattern /
    expr_no_struct

let_pattern -> Elem<'input> =
    a:Let b:pattern c:S<"="> d:expr_no_struct
    { node!("let_pattern", a, b, c, d) }

expr_if -> Elem<'input> =
    a:If b:condition c:block d:opt<expr_if_else>
    { node!("expr_if", a, b, c, d) }

expr_if_else -> Elem<'input> =
    a:Else b:block
    { node!("expr_if_else", a, b) }

expr_return -> Elem<'input> =
    a:K<"return"> b:expr
    { node!("expr_return", a, b) }

expr_break -> Elem<'input> =
    a:K<"break"> b:opt<label> c:opt<expr>
    { node!("expr_break", a, b, c) }

expr_match -> Elem<'input> =
    a:K<"match"> b:expr<(false)> c:S<"{"> d:list<match_case> e:S<"}">
    { node!("expr_match", a, b, c, d, e) }

match_case -> Elem<'input> =
    a:pattern b:opt<match_guard> c:S<"=>"> d:match_value
    { node!("match_case", a, b, c, d.0, d.1) }

match_guard -> Elem<'input> =
    a:K<"if"> b:expr<(true)>
    { node!("match_guard", a, b) }

match_value -> (Elem<'input>, Elem<'input>) =
    a:block b:opt<S<",">>
    { (a, b) }
    /
    a:expr<(true)> b:S<",">
    { (a, b) }

expr_closure -> Elem<'input> =
    a:S<"|"> b:csep<closure_param> c:S<"|"> d:closure_tail
    { node!("expr_closure", a, b, c, d.0, d.1) }

closure_param -> Elem<'input> =
    a:pattern b:opt<type_bound>
    { node!("closure_param", a, b) }

closure_tail -> (Elem<'input>, Elem<'input>) =
    a:opt<fn_return_type> b:block
    { (a, b) }
    /
    a:empty b:expr<(true)>
    { (a, b) }

empty -> Elem<'input> = { node!("empty") }

// Whitespace
_ = ([ \t\n] / "//" [^\n]* "\n")*

Ws -> Elem<'input> =
    p:$(_)
    { text(p, "") }

// Any program text
T<ex> =
    p:$(_) t:$(ex)
    { text(p, t) }

// Text with no leading whitespace allowed
T_nows<ex> =
    t:$(ex)
    { text("", t) }

// Symbols and punctuation: parens, brackets, comma, and such.
S<ex> = T<ex>

// Keywords
K<ex> = p:$(_) t:$(ex) ![a-zA-Z0-9_] {
    text(p, t)
}

Enum -> Elem<'input> = K<"enum">
Pub -> Elem<'input> = K<"pub">
Struct -> Elem<'input> = K<"struct">
Type -> Elem<'input> = K<"type">
Use -> Elem<'input> = K<"use">
Fn -> Elem<'input> = K<"fn">
Mut -> Elem<'input> = K<"mut">
Const -> Elem<'input> = K<"const">
Impl -> Elem<'input> = K<"impl">
Unsafe -> Elem<'input> = K<"unsafe">
Extern -> Elem<'input> = K<"extern">
For -> Elem<'input> = K<"for">
As -> Elem<'input> = K<"as">
FnTrait -> Elem<'input> = K<"FnOnce"> / K<"FnMut"> / K<"FnBox"> / K<"Fn">
While -> Elem<'input> = K<"while">
If -> Elem<'input> = K<"if">
Else -> Elem<'input> = K<"else">
Let -> Elem<'input> = K<"let">
Loop -> Elem<'input> =  K<"loop">
In -> Elem<'input> = K<"in">

// Identifiers
Ident -> Elem<'input> =
    T<IdentLiteral>

IdentLiteral -> &'input str =
    $([a-zA-Z_] [a-zA-Z0-9_]*)

lifetime -> Elem<'input> =
    a:Label
    { node!("lifetime", a) }

label -> Elem<'input> =
    a:Label
    { node!("iabel", a) }

Label -> Elem<'input> =
    T<"'" IdentLiteral>

// Literals
Hex = [0-9a-fA-F_]
Oct = [0-7_]
Bin = [01_]
Dec = [0-9_]

integer -> Elem<'input> =
    a:T<IntegerLiteral> b:opt<T_nows<IntegerSuffix>>
    { node!("integer", a, b) }

IntegerLiteral =
    IntegerHex /
    IntegerOct /
    IntegerBin /
    IntegerDec

IntegerHex = "0x" Hex+
IntegerOct = "0o" Oct+
IntegerBin = "0b" Bin+
IntegerDec = Dec+

IntegerSuffix =
    [ui]("8" / "16" / "32" / "64" / "128" / "size")

float -> Elem<'input> =
    a:T<IntegerDec> b:T_nows<FloatingSuffix>
    { node!("floating", a, b) }
    /
    a:T<FloatingLiteral> b:opt<T_nows<FloatingSuffix>>
    { node!("floating", a, b) }

FloatingLiteral =
    Dec* "." Dec+ FloatingExp? /
    Dec+ "." !"." FloatingExp? /
    Dec+ FloatingExp

FloatingExp =
    [eE][+-]?Dec+

FloatingSuffix = "f32" / "f64"

char -> Elem<'input> =
    a:T<"b"?> b:T_nows<[']> c:T_nows<([^'\\] / StringEscape)*> d:T_nows<[']>
    {
        let kind = if a.text() == Some("b") { "char_byte" } else { "char" };
        node!(kind, a, b, c, d)
    }

string -> Elem<'input> =
    string_normal /
    string_raw

string_normal -> Elem<'input> =
    a:T<"b"?> b:T_nows<["]> c:T_nows<([^"\\] / StringEscape)*> d:T_nows<["]>
    {
        let kind = if a.text() == Some("b") { "string_byte" } else { "string" };
        node!(kind, a, b, c, d)
    }

StringEscape =
    "\\" (["'nrt0\\\n] / "x" Hex Hex / "u{" Hex+ "}")

string_raw -> Elem<'input> =
    a:T<"b"?> b:$("r" "#"* ["]) c:T_nows<([^"] / ["] !( "#"*<{b.len()-2}> ))*> d:T_nows<["] "#"*<{b.len()-2}>>
    {
        let kind = if a.text() == Some("b") { "string_byte_raw" } else { "string_raw" };
        node!(kind, a, text("", b), c, d)
    }

// Separated lists
sep_list0<ex, sep> =
    xs:sep_elem<ex, sep>* x:sep_elem<ex, empty>?
    { node_vec("list", append(xs, x)) }

sep_list1<ex, sep> =
    xs:sep_elem<ex, sep>+ x:sep_elem<ex, empty>?
    { node_vec("list", append(xs, x)) }
    /
    x:sep_elem<ex, empty>
    { node!("list", x) }

// Separated list, tuple style - single element requires trailing separator
sep_tuple<ex, sep> =
    xs:sep_elem<ex, sep>+ x:sep_elem<ex, empty>?
    { node_vec("list", append(xs, x)) }

sep_elem<ex, sep> =
    a:ex b:sep
    { node!("list_elem", a, b) }

// Comma-separated lists
csep<ex> = sep_list0<ex, S<",">>
csep_tuple<ex> = sep_tuple<ex, S<",">>

// Non-separated lists
list<ex> = sep_list0<ex, empty>

// Optional elements
opt<ex> =
    e:ex?
    { e.unwrap_or_else(|| node!("empty")) }
